/**
  * vee-validate v4.8.4
  * (c) 2023 Abdelrahman Awad
  * @license MIT
  */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('zod')) :
    typeof define === 'function' && define.amd ? define(['exports', 'zod'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VeeValidateZod = {}, global.zod));
})(this, (function (exports, zod) { 'use strict';

    const isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);
    function isIndex(value) {
        return Number(value) >= 0;
    }
    function merge(target, source) {
        Object.keys(source).forEach(key => {
            if (isObject(source[key])) {
                if (!target[key]) {
                    target[key] = {};
                }
                merge(target[key], source[key]);
                return;
            }
            target[key] = source[key];
        });
        return target;
    }

    /**
     * Transforms a Zod object schema to Yup's schema
     */
    function toTypedSchema(zodSchema, opts) {
        const schema = {
            __type: 'VVTypedSchema',
            async parse(value) {
                const result = await zodSchema.safeParseAsync(value, opts);
                if (result.success) {
                    return {
                        value: result.data,
                        errors: [],
                    };
                }
                const errors = result.error.issues.reduce((acc, issue) => {
                    const path = joinPath(issue.path);
                    if (!acc[path]) {
                        acc[path] = { errors: [], path };
                    }
                    acc[path].errors.push(issue.message);
                    return acc;
                }, {});
                return {
                    errors: Object.values(errors),
                };
            },
            cast(values) {
                try {
                    return zodSchema.parse(values);
                }
                catch (_a) {
                    // Zod does not support "casting" or not validating a value, so next best thing is getting the defaults and merging them with the provided values.
                    const defaults = getDefaults(zodSchema);
                    if (isObject(defaults) && isObject(values)) {
                        return merge(defaults, values);
                    }
                    return values;
                }
            },
        };
        return schema;
    }
    /**
     * Constructs a path with brackets to be compatible with vee-validate path syntax
     */
    function joinPath(path) {
        let fullPath = String(path[0]);
        for (let i = 1; i < path.length; i++) {
            if (isIndex(path[i])) {
                fullPath += `[${path[i]}]`;
                continue;
            }
            fullPath += `.${path[i]}`;
        }
        return fullPath;
    }
    // Zod does not support extracting default values so the next best thing is manually extracting them.
    // https://github.com/colinhacks/zod/issues/1944#issuecomment-1406566175
    function getDefaults(schema) {
        if (!(schema instanceof zod.ZodObject)) {
            return undefined;
        }
        return Object.fromEntries(Object.entries(schema.shape).map(([key, value]) => {
            if (value instanceof zod.ZodDefault) {
                return [key, value._def.defaultValue()];
            }
            if (value instanceof zod.ZodObject) {
                return [key, getDefaults(value)];
            }
            return [key, undefined];
        }));
    }
    const toFieldValidator = toTypedSchema;
    const toFormValidator = toTypedSchema;

    exports.toFieldValidator = toFieldValidator;
    exports.toFormValidator = toFormValidator;
    exports.toTypedSchema = toTypedSchema;

}));
